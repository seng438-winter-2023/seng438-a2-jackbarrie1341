**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 â€“ Requirements-Based Test Generation**

| Group 12 |     
| -------------- |
| Student 1 - Esohe Aideyan |   
| Student 2 - Jack Barrie   |   
| Student 3 - Tamunomiete Brown |   
| Student 4 - Dyenaan Dapoet|   

# 1 Introduction

This assignment required us to work as a team in writing tests for different methods that we were given. In this lab, we were able to successfully learn and practice basic unit testing using JUnit, which we had come across but only theoretically in previous courses. We have also been able to work with mock objects in testing code with various requirements.

# 2 Detailed description of unit test strategy

Since the software being tested is a black box, our strategy used equivalence classes and boundary value testing. The initial task was to split the work evenly, so two 
people chose writing tests for DataUtilities and two for Range. Once each member had chosen methods to test, we read the JavaDocs for the respective methods. This was 
to better understand the methods, and their expected functionality. Equivilence classes were chosen to reduce the total number of tests needed to effectively test the 
methods. An example of an equivalence class is for the range function, where there are three equivalence classes to be analyzed: values below the range, values within 
the range, and values above the range. Any values chosen within these classes are considered equivelent to other values within the same class, so only one value needs
to be tested for each equivelence class. Further, we used boundary value testing to test behavior at and near the boundaries of the equivelence classes. This is done 
for more rigorous testing of the method. Tests were written using boundary value testing to ensure proper functionality of the methods at and around equivelence class 
boundaries. 

# 3 Test cases developed

Tammie - Range : getLowerBound() and getUpperBound()
Summarily,
- all tests for getLowerBound() successfully run with no errors or failures.
- tests for getUpperBound() runs with no errors but all failures (due to wrong source code).

getLowerBoundTest() methods:
each method tests for different set of ranges
- public void testCorrectLowerBound1() - between two opposite ends of the range (-200.87, 200.87)
- public void testCorrectLowerBound2() - between a random negative bound and a random positive bound (-5.69, 20.92)
- public void testCorrectLowerBound3() - between two random negative bounds (-90.99, -3.90)
- public void testCorrectLowerBound4() - between two random positive bounds (0.00, 3.89)

All these tests pass as mentioned earlier.

getUpperBoundTest() methods:
each method tests for different set of ranges
- public void testCorrectUpperBound1() - between two opposite ends of the range (-200.87, 200.87)
- public void testCorrectUpperBound2() - between a random negative bound and a random positive bound (-5.69, 20.92)
- public void testCorrectUpperBound3() - between two random negative bounds (-90.99, -3.90)
- public void testCorrectUpperBound4() - between two random positive bounds (0.00, 3.89)

All these tests fail as mentioned earlier.

Jack - Range : contains(), constrain(), and getLength()
Only one unit test failed: inputBelowLowerBoundShouldReturnLowerBound()

contains() unit tests:
 - public void inputBelowLowerBoundShouldBeFalse() - tests input just below lower bound of range, test passed
 - public void inputAtLowerBoundShouldBeTrue() - tests input at lower bound of range, test passed
 - public void inputAboveLowerBoundShouldBeTrue() - tests input just above lower bound of range, test passed
 - public void inputOfNominalValueShouldBeTrue() - tests input of a nominal value in range, test passed
 - public void inputBelowUpperBoundShouldBeTrue() - tests input just below upper bound of range, test passed
 - public void inputAtUpperBoundShouldBeTrue() - tests input at upper bound of range, test passed
 - public void inputAboveUpperBoundShouldBeFalse() - tests input just above upper bound, test passed

constrain() unit tests:
 - public void inputBelowLowerBoundShouldReturnLowerBound() - tests input just below lower bound of range, test failed
 - public void inputOfLowerBoundShouldReturnLowerBound() - tests input at lower bound of range, test passed
 - public void inputAboveLowerBoundShouldReturnInputValue() - tests input just above lower bound of range, test passed
 - public void inputOfNominalValueShouldReturnInputValue() - tests input of a nominal value in range, test passed
 - public void inputBelowUpperBoundShouldReturnInputValue() - tests input just below upper bound of range, test passed
 - public void inputAtUpperBoundShouldReturnUpperBound() - tests input at upper bound of range, test passed
 - public void inputAboveUpperBoundShouldReturnUpperBound() - tests input just above upper bound, test passed

getLength() unit tests:
- public void testNegativeUpperAndLowerBounds() - tests getLength() when the range is between two negative values, test passed
- public void testNegativeLowerBoundPositiveUpperBound() - tests getLength() when the range is between a negative and positive value, test passed
- public void testPositiveUpperBoundAndLowerBounds() - tests getLength() when the range is between two positive values, test passed
- public void testUpperBoundEqualsLowerBound() - tests getLength() when the upper and lower bounds of the range are equal, test passed

Esohe - DataUtilities: createNumberArray2D() and getCumulativePercentages()
-For createNumberArray2D tests, 4/7 tests failed
-For getCumulativePercentages tests, 2/4 tests fails

createNumberArray2D unit tests:



# 4 How the team work/effort was divided and managed

We had 10 tests to work on between 4 members: 5 from Range and 5 from DataUtilities so we decided to divide the work load between group members in two's, while two members volunteered to do three; so the final distribution was 3-3-2-2, corresponding to Dyenaan-Jack-Esohe-Tammie. Dyenaan worked on three tests from DataUtilities, Jack worked on three tests from Range, Esohe worked on the remaining two tests from DataUtilities and Tammie worked on two tests from Range.

Regardless of the fact that we split the tests as such, in order to ensure that every member has an all-round understanding of the assignment, we met up and went over each other's tests in detail.

# 5 Difficulties encountered, challenges overcome, and lessons learned

During this lab a challenge we encountered was knowing how to use the jMock testing. As this was the groups first time working with mockery, it posed as a setback in completing this lab because we did not fully understand how it will be incorporated in the tests we were supposed to write. Another challenge we encountered was while following the instructions in the lab manual, our tests threw some errors that we had not come across before and did not know how to fix.
To overcome these challenges, the group took some time to gain familiarity with mock testing and understand the concepts as well as the errors while using mock testing, we consulted youtube videos, articles and previous mock testing examples to help with understanding.

# 6 Comments/feedback on the lab itself

The lab was very engaging and enabled the groups to come up with valid test cases for various methods in the classes, it also helped to improve our understanding of testing using JUnit and Mocking. However, to improve this lab, I would suggest the instructions/manual be up to date with the latest version of programs and application needed during the lab. The lab manual should also provide some infromation concerning common errors and solutions when working with the programs needed while doing the lab.
